// Code generated by cue_gen. DO NOT EDIT.
package {{.Name}}_infra

import (
	"context"
	"cloud.google.com/go/spanner"
	"google.golang.org/api/iterator"
	"github.com/pkg/errors"

	"github.com/tusmasoma/cue-gen-samples/pkg/infra/spanner/model/user/{{.Name}}"
)

// IFInfra - インフラ層のインターフェース
type IFInfra interface {
	Get(ctx context.Context,
		{{- range .PrimaryKeys }}
		{{.Name | lowerCamelcase}} {{.GoType}},
		{{- end }}
	) (*{{.Name}}.Model, error)

	TryGet(ctx context.Context,
		{{- range .PrimaryKeys }}
		{{.Name | lowerCamelcase}} {{.GoType}},
		{{- end }}
	) (*{{.Name}}.Model, bool, error)

	FindByConditions(ctx context.Context, cond *{{.Name | upperCamelcase}}Condition) ({{.Name}}.Models, error)

	Insert(ctx context.Context, model *{{.Name}}.Model) error
	Update(ctx context.Context, model *{{.Name}}.Model) error
	Delete(ctx context.Context, model *{{.Name}}.Model) error
	Save(ctx context.Context, model *{{.Name}}.Model) error
}

// NewInfra - 新規作成
func NewInfra(client *spanner.Client) *Infra {
	return &Infra{client: client}
}

// Infra - インフラ層の実装
type Infra struct {
	client *spanner.Client
}

var _ IFInfra = (*Infra)(nil)

// Get - 取得
func (i *Infra) Get(ctx context.Context,
	{{- range .PrimaryKeys }}
	{{.Name | lowerCamelcase}} {{.GoType}},
	{{- end }}
) (*{{.Name}}.Model, error) {
	row, err := i.client.Single().ReadRow(ctx, {{.Name}}.TableName, spanner.Key{
		{{- range .PrimaryKeys }}
		{{.Name | lowerCamelcase}},
		{{- end }}
	}, {{.Name}}.Columns)

	if err != nil {
		return nil, errors.Wrap(err, "failed to get data from spanner")
	}

	var model {{.Name}}.Model
	if err := model.Bind(row); err != nil {
		return nil, errors.Wrap(err, "failed to bind row data")
	}

	return &model, nil
}

// TryGet - 取得（エラー時に false を返す）
func (i *Infra) TryGet(ctx context.Context,
	{{- range .PrimaryKeys }}
	{{.Name | lowerCamelcase}} {{.GoType}},
	{{- end }}
) (*{{.Name}}.Model, bool, error) {
	model, err := i.Get(ctx, {{- range .PrimaryKeys }}{{.Name | lowerCamelcase}}, {{- end }})
	if err != nil {
		if spanner.ErrCode(err) == spanner.ErrRowNotFound {
			return nil, false, nil
		}
		return nil, false, err
	}
	return model, true, nil
}

// Insert - データを挿入
func (i *Infra) Insert(ctx context.Context, model *{{.Name}}.Model) error {
	mutation := model.InsertMutation()
	_, err := i.client.Apply(ctx, []*spanner.Mutation{mutation})
	return errors.Wrap(err, "failed to insert data into spanner")
}

// Update - データを更新
func (i *Infra) Update(ctx context.Context, model *{{.Name}}.Model) error {
	mutation := model.UpdateMutation()
	_, err := i.client.Apply(ctx, []*spanner.Mutation{mutation})
	return errors.Wrap(err, "failed to update data in spanner")
}

// Delete - データを削除
func (i *Infra) Delete(ctx context.Context, model *{{.Name}}.Model) error {
	mutation := model.DeleteMutation()
	_, err := i.client.Apply(ctx, []*spanner.Mutation{mutation})
	return errors.Wrap(err, "failed to delete data from spanner")
}

// Save - データを保存（存在しなければ Insert、存在すれば Update）
func (i *Infra) Save(ctx context.Context, model *{{.Name}}.Model) error {
	_, exists, err := i.TryGet(ctx, {{- range .PrimaryKeys }}model.{{.Name | upperCamelcase}}, {{- end }})
	if err != nil {
		return err
	}
	if exists {
		return i.Update(ctx, model)
	}
	return i.Insert(ctx, model)
}

// Condition - 検索条件
type {{.Name | upperCamelcase}}Condition struct {
    {{- range .Columns }}
    {{ .Name | upperCamelcase }} *{{ .GoType }}
    {{- end }}
}

// toConditions - WHERE 句を生成
func (c *{{.Name | upperCamelcase}}Condition) toConditions() (string, map[string]interface{}, error) {
    conditions := []string{}
    params := map[string]interface{}{}

    {{- range .Columns }}
    if c.{{ .Name | upperCamelcase }} != nil {
        paramKey := "{{ .Name }}"
        conditions = append(conditions, fmt.Sprintf("%s = @%s", paramKey, paramKey))
        params[paramKey] = *c.{{ .Name | upperCamelcase }}
    }
    {{- end }}

    if len(conditions) == 0 {
        return "", nil, errors.New("条件が指定されていません")
    }

    return strings.Join(conditions, " AND "), params, nil
}

// FindByConditions - 条件検索
func (i *Infra) FindByConditions(ctx context.Context, cond *{{.Name | upperCamelcase}}Condition) ({{.Name}}.Models, error) {
    whereClause, params, err := cond.toConditions()
    if err != nil {
        return nil, err
    }

    query := fmt.Sprintf("SELECT * FROM %s WHERE %s", {{.Name}}.TableName, whereClause)

    stmt := spanner.Statement{
        SQL:    query,
        Params: params,
    }

    iter := i.client.Single().Query(ctx, stmt)
    defer iter.Stop()

    var models {{.Name}}.Models
    for {
        row, err := iter.Next()
        if err == iterator.Done {
            break
        }
        if err != nil {
            return nil, errors.Wrap(err, "failed to query spanner")
        }

        var model {{.Name}}.Model
        if err := model.Bind(row); err != nil {
            return nil, errors.Wrap(err, "failed to bind row data")
        }
        models = append(models, &model)
    }

    return models, nil
}
